#!/usr/bin/env python3
import sys
import os
import re
import string
import unicodedata
import subprocess
import importlib


# Import the required modules after ensuring they are installed
import fitz  # PyMuPDF
from habanero import Crossref
from loguru import logger
from rich.console import Console

# Set up logging with loguru
logger.remove()  # Remove the default logger
logger.add(sys.stderr, level="INFO")

# Set up rich console
console = Console()

# Checking for internet connection
def check_internet_access():
    try:
        subprocess.check_call(["ping", "-c", "1", "google.com"])
        return True
    except subprocess.CalledProcessError:
        return False

# Limiting filenames to valid characters
def remove_invalid_characters(text):
    valid_characters = "-_.() %s%s" % (string.ascii_letters, string.digits)
    cleaned_text = ''.join(
        c if c in valid_characters or unicodedata.category(c) in ('Mn', 'Mc', 'Ll', 'Lu', 'Lt', 'Lo') else '_'
        for c in text
    )
    return cleaned_text

# Opening PDF file, reading the first page and extracting DOI with a very common pattern
def extract_metadata_from_pdf(pdf_file):
    try:
        pdf_document = fitz.open(pdf_file)
        first_page = pdf_document[0]
        text = first_page.get_text("text")
        doi_pattern = r'10[.][\d.]{1,15}\/[-._;:()\/A-Za-z0-9<>]+[A-Za-z0-9]'
        doi_match = re.search(doi_pattern, text)
        if doi_match:
            doi = doi_match.group()
            logger.info("Extracting DOI from file")
            return fetch_metadata_by_doi(doi)
        else:
            return None
    except Exception as e:
        logger.error(f"Error extracting metadata from PDF: {e}")
        return None

# Using Crossref API to match the extracted DOI
def fetch_metadata_by_doi(doi):
    try:
        cr = Crossref()
        metadata = cr.works(doi)
        logger.info("Extracting metadata through crossref.org")
        return metadata
    except Exception as e:
        logger.error(f"Error fetching metadata by DOI: {e}")
        return None

# Extracting family name for the authors
def format_author_names(authors):
    if len(authors) == 1:
        return authors[0]['family']
    elif len(authors) == 2:
        return f"{authors[0]['family']} and {authors[1]['family']}"
    else:
        return f"{authors[0]['family']} et al."

# Saving required information from the metadata to the file and removing invalid characters
def rename_pdf_file(pdf_file, metadata):
    try:
        authors = metadata['message']['author']
        author_names = format_author_names(authors)
        title = metadata['message']['title'][0]
        year = metadata['message']['issued']['date-parts'][0][0]
        publication = metadata['message']['container-title'][0] if 'container-title' in metadata['message'] else 'Unknown publication'
        publisher = metadata['message']['publisher'] if 'publisher' in metadata['message'] else 'Unknown publisher'

        cleaned_authornames = remove_invalid_characters(author_names)
        cleaned_title = remove_invalid_characters(title)
        cleaned_year = remove_invalid_characters(str(year))
        cleaned_publication = remove_invalid_characters(publication)
        cleaned_publisher = remove_invalid_characters(publisher)

        max_title_length = 255 - len(cleaned_authornames) - len(str(year)) - len(cleaned_publication) - len(cleaned_publisher) - len(" () ... @  - .pdf")

        if len(cleaned_title) <= max_title_length:
            cleaned_title = cleaned_title
        else:
            cleaned_title = cleaned_title[:max_title_length] + "..."

        new_filename = f"{cleaned_authornames} ({cleaned_year}) {cleaned_title} @ {cleaned_publication} - {cleaned_publisher}.pdf"

        os.rename(pdf_file, os.path.join(os.path.dirname(pdf_file), new_filename))
        return new_filename
    except Exception as e:
        logger.error(f"Error renaming PDF file: {e}")
        return None

# Processing folder or file
def process_folder_or_file(path):
    if os.path.isdir(path):
        process_folder(path)
    elif os.path.isfile(path) and path.lower().endswith('.pdf'):
        pdf_file = path
        metadata = extract_metadata_from_pdf(pdf_file)

        if metadata:
            new_file_name = rename_pdf_file(pdf_file, metadata)
            if new_file_name:
                console.print(f"[green]File renamed to: {new_file_name}[/green]")
        else:
            console.print(f"[yellow]DOI not found in {pdf_file}.[/yellow]")
    else:
        console.print("[red]Invalid input. Please provide a valid folder path or PDF file path.[/red]")

# Processing folder
def process_folder(folder_path):
    for root, _, files in os.walk(folder_path):
        for file in files:
            if file.endswith(".pdf"):
                pdf_file = os.path.join(root, file)
                metadata = extract_metadata_from_pdf(pdf_file)

                if metadata:
                    new_file_name = rename_pdf_file(pdf_file, metadata)
                    if new_file_name:
                        console.print(f"[green]File renamed to: {new_file_name}[/green]")
                else:
                    console.print(f"[yellow]DOI not found in {pdf_file}.[/yellow]")

# Main code
if __name__ == "__main__":
    if not check_internet_access():
        console.print("[red]Internet Connection Unavailable. The program requires internet access to extract metadata for renaming.[/red]")
        sys.exit(1)
    if len(sys.argv) != 2:
        console.print("[red]Usage: python rename_pdf_by_metadata.py <FOLDER_PATH_OR_PDF_FILE_PATH>[/red]")
        sys.exit(1)

    path = sys.argv[1]
    process_folder_or_file(path)
    
